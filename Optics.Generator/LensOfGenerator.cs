using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

using static Macaron.Optics.Generator.Helpers;

namespace Macaron.Optics.Generator;

[Generator]
public class LensOfGenerator : IIncrementalGenerator
{
    #region Constants
    private const string LensOfAttributeSource =
        """
        // <auto-generated />
        #nullable enable

        using System;
        using System.Diagnostics;

        namespace Macaron.Optics
        {
            [Conditional("SOURCE_GENERATOR_ONLY")]
            [AttributeUsage(AttributeTargets.Class, Inherited = false)]
            internal class LensOfAttribute : Attribute
            {
                public Type? TargetType { get; }

                public LensOfAttribute(Type? targetType = null)
                {
                    TargetType = targetType;
                }
            }
        }

        """;
    private const string OptionalOfAttributeSource =
        """
        // <auto-generated />
        #nullable enable

        using System;
        using System.Diagnostics;

        namespace Macaron.Optics
        {
            [Conditional("SOURCE_GENERATOR_ONLY")]
            [AttributeUsage(AttributeTargets.Class, Inherited = false)]
            internal class OptionalOfAttribute : Attribute
            {
                public Type? TargetType { get; }

                public OptionalOfAttribute(Type? targetType = null)
                {
                    TargetType = targetType;
                }
            }
        }

        """;
    #endregion

    #region IIncrementalGenerator Interface
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.AddSource("LensOfAttribute.g.cs", SourceText.From(LensOfAttributeSource, Encoding.UTF8));
            context.AddSource("OptionalOfAttribute.g.cs", SourceText.From(OptionalOfAttributeSource, Encoding.UTF8));
        });

        var visitedTypes = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
        IncrementalValuesProvider<AttributeContext> valuesProvider = context
            .SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (syntaxNode, _) => syntaxNode is ClassDeclarationSyntax,
                transform: (generatorSyntaxContext, _) => GetAttributeContext(generatorSyntaxContext, visitedTypes)
            );

        context.RegisterSourceOutput(
            source: valuesProvider,
            action: (sourceProductionContext, attributeContext) =>
            {
                foreach (var diagnostic in attributeContext.Diagnostics)
                {
                    sourceProductionContext.ReportDiagnostic(diagnostic);
                }

                switch (attributeContext)
                {
                    case LensOfAttributeContext
                    {
                        ContainingTypeSymbol: { } containingTypeSymbol,
                        TypeSymbol: { } typeSymbol
                    }:
                    {
                        AddSource(
                            sourceProductionContext: sourceProductionContext,
                            attributeContext: (containingTypeSymbol, typeSymbol),
                            generateMembers: GenerateLensOfMembers
                        );
                        break;
                    }
                    case OptionalOfAttributeContext
                    {
                        ContainingTypeSymbol: { } containingTypeSymbol,
                        TypeSymbol: { } typeSymbol
                    }:
                    {
                        AddSource(
                            sourceProductionContext: sourceProductionContext,
                            attributeContext: (containingTypeSymbol, typeSymbol),
                            generateMembers: GenerateOptionalOfMembers
                        );
                        break;
                    }
                }
            });
    }
    #endregion
}
