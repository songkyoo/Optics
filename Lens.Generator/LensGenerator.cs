using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Lens.Generator;

[Generator]
public class LensGenerator : IIncrementalGenerator
{
    #region Static
    private static string? ToFullyQualifiedName(ISymbol? symbol)
    {
        return symbol?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
    }

    private static string? GetLensOfType(GeneratorSyntaxContext generatorSyntaxContext)
    {
        var invocationExpressionSyntax = (InvocationExpressionSyntax)generatorSyntaxContext.Node;

        if (invocationExpressionSyntax.Expression is MemberAccessExpressionSyntax
            {
                Name: GenericNameSyntax
                {
                    Identifier.Text: "Of",
                    TypeArgumentList.Arguments.Count: 1,
                } genericName
            }
        )
        {
            var symbol = generatorSyntaxContext.SemanticModel.GetSymbolInfo(genericName).Symbol as IMethodSymbol;
            if (symbol?.IsStatic is true &&
                ToFullyQualifiedName(symbol.ContainingType) == "global::Macaron.Optics.Lens"
            )
            {
                var typeSymbol = generatorSyntaxContext
                    .SemanticModel
                    .GetTypeInfo(genericName.TypeArgumentList.Arguments[0])
                    .Type;
                return ToFullyQualifiedName(typeSymbol);
            }
        }

        return null;
    }

    private static bool IsValidProperty(IPropertySymbol propertySymbol)
    {
        if (propertySymbol.GetMethod is null)
        {
            return false;
        }

        if (propertySymbol.IsIndexer)
        {
            return false;
        }

        return propertySymbol.SetMethod is not null or { IsReadOnly: true };
    }

    private static bool IsValidField(IFieldSymbol fieldSymbol)
    {
        return !fieldSymbol.IsReadOnly;
    }

    private static void GenerateSource(
        SourceProductionContext sourceProductionContext,
        ImmutableArray<string> lensTypeNames,
        Compilation compilation
    )
    {
        var uniqueTypeNames = lensTypeNames.Distinct();
        var stringBuilder = new StringBuilder();

        stringBuilder.AppendLine("// <auto-generated />");

        foreach (var typeName in uniqueTypeNames)
        {
            var sanitizedTypeName = typeName.Replace("global::", "");
            var typeSymbol = compilation.GetTypeByMetadataName(sanitizedTypeName);
            if (typeSymbol is null)
            {
                continue;
            }

            var members = typeSymbol
                .GetMembers()
                .Where(symbol => symbol.DeclaredAccessibility == Accessibility.Public)
                .Where(symbol =>
                    (symbol is IPropertySymbol prop && IsValidProperty(prop)) ||
                    (symbol is IFieldSymbol field && IsValidField(field))
                )
                .ToArray();
            if (!members.Any())
            {
                continue;
            }

            stringBuilder.AppendLine($"public static class global_Macaron_Optics_LensOf_{sanitizedTypeName.Replace('.', '_')}");
            stringBuilder.AppendLine("{");

            foreach (var member in members)
            {
                var memberType = ToFullyQualifiedName(member is IPropertySymbol prop
                    ? prop.Type
                    : ((IFieldSymbol)member).Type
                );

                stringBuilder.AppendLine($"    public static global::Macaron.Optics.Lens<{typeName}, {memberType}> {member.Name}(");
                stringBuilder.AppendLine($"        this global::Macaron.Optics.LensOf<{typeName}> lensOf");
                stringBuilder.AppendLine("    )");
                stringBuilder.AppendLine("    {");
                stringBuilder.AppendLine($"        return global::Macaron.Optics.Lens<{typeName}, {memberType}>.Of(");
                stringBuilder.AppendLine($"            getter: static source => source.{member.Name},");
                stringBuilder.AppendLine($"            setter: static (source, value) => source with");
                stringBuilder.AppendLine("            {");
                stringBuilder.AppendLine($"                {member.Name} = value,");
                stringBuilder.AppendLine("            }");
                stringBuilder.AppendLine("        );");
                stringBuilder.AppendLine("    }");
            }

            stringBuilder.AppendLine("}");
            stringBuilder.AppendLine();
        }

        sourceProductionContext.AddSource(
            hintName: "LensOf_1Extensions.g.cs",
            sourceText: SourceText.From(stringBuilder.ToString(), Encoding.UTF8)
        );
    }
    #endregion

    #region IIncrementalGenerator Interface
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var lensOfCalls = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (syntaxNode, _) => syntaxNode is InvocationExpressionSyntax,
                transform: static (generatorSyntaxContext, _) => GetLensOfType(generatorSyntaxContext)
            )
            .Where(static typeName => typeName is not null)
            .Select(static (typeName, _) => typeName!)
            .Collect();

        context.RegisterSourceOutput(
            source: lensOfCalls.Combine(context.CompilationProvider),
            action: (sourceProductionContext, source) => GenerateSource(
                sourceProductionContext,
                source.Left,
                source.Right
            )
        );
    }
    #endregion
}
