using System.Collections.Immutable;
using System.Reflection;
using Macaron.Optics.Generator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace Macaron.Optics.Tests;

public class LensOfGeneratorTests
{
    private static void AssertGeneratedCode(string sourceCode, params string[] expected)
    {
        var (_, generatedCodes) = CompileAndGetResults<LensOfGenerator>(
            sourceCode,
            skipGeneratedCodeCount: 2, // 0, 1번은 LensOfAttribute.g.cs, OptionalOfAttribute.g.cs
            additionalAssemblies: [typeof(LensOf<>).Assembly]
        );

        Assert.That(generatedCodes, Has.Length.EqualTo(expected.Length));

        for (int i = 0; i < generatedCodes.Length; i++)
        {
            var generatedCode = generatedCodes[i];
            Assert.That(generatedCode.ReplaceLineEndings(), Is.EqualTo(expected[i].ReplaceLineEndings()));
        }
    }

    private static void AssertDiagnostic(string sourceCode, string expectedDiagnosticId)
    {
        var (diagnostics, _) = CompileAndGetResults<LensOfGenerator>(
            sourceCode,
            skipGeneratedCodeCount: 2,
            additionalAssemblies: [typeof(LensOf<>).Assembly]
        );

        var actualDiagnosticIds = diagnostics
            .Where(diagnostic => diagnostic.Severity == DiagnosticSeverity.Error)
            .Select(diagnostic => diagnostic.Id)
            .ToArray();

        Assert.That(actualDiagnosticIds, Has.Some.Matches(expectedDiagnosticId));
    }

    private static (ImmutableArray<Diagnostic> Diagnostics, ImmutableArray<string> GeneratedCodes) CompileAndGetResults<T>(
        string sourceCode,
        int skipGeneratedCodeCount,
        Assembly[]? additionalAssemblies = null
    ) where T : IIncrementalGenerator, new()
    {
        var references = AppDomain
            .CurrentDomain
            .GetAssemblies()
            .Concat(additionalAssemblies ?? [])
            .Where(assembly => !assembly.IsDynamic && !string.IsNullOrWhiteSpace(assembly.Location))
            .Select(assembly => MetadataReference.CreateFromFile(assembly.Location))
            .Cast<MetadataReference>()
            .ToImmutableArray();

        var syntaxTree = CSharpSyntaxTree.ParseText(sourceCode);
        var compilation = CSharpCompilation.Create(
            assemblyName: "Macaron.InterfaceDelegation.Tests",
            syntaxTrees: [syntaxTree],
            references: references,
            options: new CSharpCompilationOptions(
                outputKind: OutputKind.DynamicallyLinkedLibrary,
                nullableContextOptions: NullableContextOptions.Enable
            )
        );

        var generator = new T();
        var driver = CSharpGeneratorDriver.Create(generator);

        var result = driver.RunGenerators(compilation).GetRunResult().Results.Single();
        var generatedSources = result.GeneratedSources;
        var generatedCodes = generatedSources.Length > skipGeneratedCodeCount
            ? generatedSources.Skip(skipGeneratedCodeCount).Select(source => source.SourceText.ToString()).ToImmutableArray()
            : ImmutableArray<string>.Empty;

        var allDiagnostics = compilation.GetDiagnostics()
            .Concat(result.Diagnostics)
            .ToImmutableArray();

        return (allDiagnostics, generatedCodes);
    }

    [Test]
    public void When_LensOfAttributeWithoutTypeArgument_Should_UseContainingType()
    {
        AssertGeneratedCode(
            sourceCode:
            """
            namespace Macaron.Optics.Tests;

            public partial record Person(string Name, int Age)
            {
                [LensOf]
                public static partial class Lens
                {
                }
            }

            """,
            expected:
            """
            // <auto-generated />
            #nullable enable

            namespace Macaron.Optics.Tests
            {
                partial record Person
                {
                    partial class Lens
                    {
                        public static readonly global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Person, string> Name = global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Person, string>.Of(
                            getter: static source => source.Name,
                            setter: static (source, value) => source with
                            {
                                Name = value,
                            }
                        );

                        public static readonly global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Person, int> Age = global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Person, int>.Of(
                            getter: static source => source.Age,
                            setter: static (source, value) => source with
                            {
                                Age = value,
                            }
                        );
                    }
                }
            }

            """
        );
    }
    [Test]
    public void When_LensOfAttributeWithTypeArgument_Should_UseSpecifiedType()
    {
        AssertGeneratedCode(
            sourceCode:
            """
            namespace Macaron.Optics.Tests;

            public partial record Person(string Name, int Age);

            [LensOf(typeof(Person))]
            public static partial class PersonLens
            {
            }
            """,
            expected:
            """
            // <auto-generated />
            #nullable enable

            namespace Macaron.Optics.Tests
            {
                partial class PersonLens
                {
                    public static readonly global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Person, string> Name = global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Person, string>.Of(
                        getter: static source => source.Name,
                        setter: static (source, value) => source with
                        {
                            Name = value,
                        }
                    );

                    public static readonly global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Person, int> Age = global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Person, int>.Of(
                        getter: static source => source.Age,
                        setter: static (source, value) => source with
                        {
                            Age = value,
                        }
                    );
                }
            }

            """
        );
    }

    [Test]
    public void When_OptionalOfAttribute_Should_GenerateOptionalLenses()
    {
        AssertGeneratedCode(
            sourceCode:
            """
            using Macaron.Functional;

            namespace Macaron.Optics.Tests;

            public partial record Person(string Name, int Age);

            [OptionalOf(typeof(Person))]
            public static partial class PersonOptional
            {
            }
            """,
            expected:
            """
            // <auto-generated />
            #nullable enable

            namespace Macaron.Optics.Tests
            {
                partial class PersonOptional
                {
                    public static readonly global::Macaron.Optics.Optional<global::Macaron.Functional.Maybe<global::Macaron.Optics.Tests.Person>, string> Name = global::Macaron.Optics.Optional<global::Macaron.Functional.Maybe<global::Macaron.Optics.Tests.Person>, string>.Of(
                        optionalGetter: static source => source.IsJust
                            ? global::Macaron.Functional.Maybe.Just(source.Value.Name)
                            : global::Macaron.Functional.Maybe.Nothing<string>(),
                        setter: static (source, value) => source.IsJust
                            ? global::Macaron.Functional.Maybe.Just(source.Value with
                            {
                                Name = value,
                            })
                            : global::Macaron.Functional.Maybe.Nothing<global::Macaron.Optics.Tests.Person>()
                    );

                    public static readonly global::Macaron.Optics.Optional<global::Macaron.Functional.Maybe<global::Macaron.Optics.Tests.Person>, int> Age = global::Macaron.Optics.Optional<global::Macaron.Functional.Maybe<global::Macaron.Optics.Tests.Person>, int>.Of(
                        optionalGetter: static source => source.IsJust
                            ? global::Macaron.Functional.Maybe.Just(source.Value.Age)
                            : global::Macaron.Functional.Maybe.Nothing<int>(),
                        setter: static (source, value) => source.IsJust
                            ? global::Macaron.Functional.Maybe.Just(source.Value with
                            {
                                Age = value,
                            })
                            : global::Macaron.Functional.Maybe.Nothing<global::Macaron.Optics.Tests.Person>()
                    );
                }
            }

            """
        );
    }

    [Test]
    public void When_RecordWithNullableProperties_Should_GenerateMaybeLenses()
    {
        AssertGeneratedCode(
            sourceCode:
            """
            namespace Macaron.Optics.Tests;

            public partial record Person(string Name, string? Email, int? Age)
            {
                [LensOf]
                public static partial class Lens
                {
                }
            }
            """,
            expected:
            """
            // <auto-generated />
            #nullable enable

            namespace Macaron.Optics.Tests
            {
                partial record Person
                {
                    partial class Lens
                    {
                        public static readonly global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Person, string> Name = global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Person, string>.Of(
                            getter: static source => source.Name,
                            setter: static (source, value) => source with
                            {
                                Name = value,
                            }
                        );

                        public static readonly global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Person, global::Macaron.Functional.Maybe<string>> Email = global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Person, global::Macaron.Functional.Maybe<string>>.Of(
                            getter: static source => source is { Email: { } value }
                                ? global::Macaron.Functional.Maybe.Just(value)
                                : global::Macaron.Functional.Maybe.Nothing<string>(),
                            setter: static (source, value) => source with
                            {
                                Email = value is { IsJust: true, Value: var value2 } ? value2 : null,
                            }
                        );

                        public static readonly global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Person, global::Macaron.Functional.Maybe<int>> Age = global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Person, global::Macaron.Functional.Maybe<int>>.Of(
                            getter: static source => source is { Age: { } value }
                                ? global::Macaron.Functional.Maybe.Just(value)
                                : global::Macaron.Functional.Maybe.Nothing<int>(),
                            setter: static (source, value) => source with
                            {
                                Age = value is { IsJust: true, Value: var value2 } ? value2 : null,
                            }
                        );
                    }
                }
            }

            """
        );
    }

    [Test]
    public void When_StructWithProperties_Should_GenerateLenses()
    {
        AssertGeneratedCode(
            sourceCode:
            """
            namespace Macaron.Optics.Tests;

            public partial struct Point
            {
                public int X { get; set; }
                public int Y { get; set; }

                [LensOf]
                public static partial class Lens
                {
                }
            }
            """,
            expected:
            """
            // <auto-generated />
            #nullable enable

            namespace Macaron.Optics.Tests
            {
                partial struct Point
                {
                    partial class Lens
                    {
                        public static readonly global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Point, int> X = global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Point, int>.Of(
                            getter: static source => source.X,
                            setter: static (source, value) => source with
                            {
                                X = value,
                            }
                        );

                        public static readonly global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Point, int> Y = global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Point, int>.Of(
                            getter: static source => source.Y,
                            setter: static (source, value) => source with
                            {
                                Y = value,
                            }
                        );
                    }
                }
            }

            """
        );
    }

    [Test]
    public void When_NestedClasses_Should_GenerateWithCorrectIndentation()
    {
        AssertGeneratedCode(
            sourceCode:
            """
            namespace Macaron.Optics.Tests;

            public partial class Outer
            {
                public partial class Inner
                {
                    public partial record Person(string Name)
                    {
                        [LensOf]
                        public static partial class Lens
                        {
                        }
                    }
                }
            }
            """,
            expected:
            """
            // <auto-generated />
            #nullable enable

            namespace Macaron.Optics.Tests
            {
                partial class Outer
                {
                    partial class Inner
                    {
                        partial record Person
                        {
                            partial class Lens
                            {
                                public static readonly global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Outer.Inner.Person, string> Name = global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Outer.Inner.Person, string>.Of(
                                    getter: static source => source.Name,
                                    setter: static (source, value) => source with
                                    {
                                        Name = value,
                                    }
                                );
                            }
                        }
                    }
                }
            }

            """
        );
    }

    [Test]
    public void When_NoPublicProperties_Should_GenerateNothing()
    {
        AssertGeneratedCode(
            sourceCode:
            """
            namespace Macaron.Optics.Tests;

            public partial record Empty
            {
                private int value;

                [LensOf]
                public static partial class Lens
                {
                }
            }
            """,
            expected: []
        );
    }

    [Test]
    public void When_InheritedProperties_Should_GenerateLenses()
    {
        AssertGeneratedCode(
            sourceCode:
            """
            namespace Macaron.Optics.Tests;

            public partial record Animal(string Name);
            public partial record Dog(string Name, string Breed) : Animal(Name)
            {
                [LensOf]
                public static partial class Lens
                {
                }
            }
            """,
            expected:
            """
            // <auto-generated />
            #nullable enable

            namespace Macaron.Optics.Tests
            {
                partial record Dog
                {
                    partial class Lens
                    {
                        public static readonly global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Dog, string> Breed = global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Dog, string>.Of(
                            getter: static source => source.Breed,
                            setter: static (source, value) => source with
                            {
                                Breed = value,
                            }
                        );

                        public static readonly global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Dog, string> Name = global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.Dog, string>.Of(
                            getter: static source => source.Name,
                            setter: static (source, value) => source with
                            {
                                Name = value,
                            }
                        );
                    }
                }
            }

            """
        );
    }

    [Test]
    public void When_MixedProperties_Should_OnlyGenerateForValidOnes()
    {
        AssertGeneratedCode(
            sourceCode:
            """
            namespace Macaron.Optics.Tests;

            public partial struct TestClass
            {
                public string ValidProperty { get; set; }
                public string ReadOnlyProperty { get; }
                public string InitOnlyProperty { get; init; }
                public string this[int index] => ""; // Indexer
                private string PrivateProperty { get; set; }
                public static string StaticProperty { get; set; }
                public const string ConstField = "const";
                public readonly string ReadOnlyField = "readonly";
                public string PublicField;

                [LensOf]
                public static partial class Lens
                {
                }
            }
            """,
            expected:
            """
            // <auto-generated />
            #nullable enable

            namespace Macaron.Optics.Tests
            {
                partial struct TestClass
                {
                    partial class Lens
                    {
                        public static readonly global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.TestClass, string> ValidProperty = global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.TestClass, string>.Of(
                            getter: static source => source.ValidProperty,
                            setter: static (source, value) => source with
                            {
                                ValidProperty = value,
                            }
                        );

                        public static readonly global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.TestClass, string> InitOnlyProperty = global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.TestClass, string>.Of(
                            getter: static source => source.InitOnlyProperty,
                            setter: static (source, value) => source with
                            {
                                InitOnlyProperty = value,
                            }
                        );

                        public static readonly global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.TestClass, string> PublicField = global::Macaron.Optics.Lens<global::Macaron.Optics.Tests.TestClass, string>.Of(
                            getter: static source => source.PublicField,
                            setter: static (source, value) => source with
                            {
                                PublicField = value,
                            }
                        );
                    }
                }
            }

            """
        );
    }

    [Test]
    public void When_AttributeOnNonStaticClass_Should_ReportError()
    {
        AssertDiagnostic(
            sourceCode:
            """
            namespace Macaron.Optics.Tests;

            public partial record Person(string Name);

            [LensOf(typeof(Person))]
            public partial class PersonLens
            {
            }
            """,
            expectedDiagnosticId: "MAOG0003"
        );
    }

    [Test]
    public void When_AttributeTargetIsInterface_Should_ReportError()
    {
        AssertDiagnostic(
            sourceCode:
            """
            namespace Macaron.Optics.Tests;

            public interface IPerson
            {
                string Name { get; }
            }

            [LensOf(typeof(IPerson))]
            public static partial class PersonLens
            {
            }
            """,
            expectedDiagnosticId: "MAOG0004"
        );
    }

    [Test]
    public void When_AttributeTargetIsNormalClass_Should_ReportError()
    {
        AssertDiagnostic(
            sourceCode:
            """
            namespace Macaron.Optics.Tests;

            public class Person
            {
                public string Name { get; set; }
            }

            [LensOf(typeof(Person))]
            public static partial class PersonLens
            {
            }
            """,
            expectedDiagnosticId: "MAOG0004"
        );
    }

    [Test]
    public void When_GlobalNamespace_Should_GenerateWithoutNamespaceBlock()
    {
        AssertGeneratedCode(
            sourceCode:
            """
            using Macaron.Optics;

            public partial record Person(string Name)
            {
                [LensOf]
                public static partial class Lens
                {
                }
            }
            """,
            expected:
            """
            // <auto-generated />
            #nullable enable

            partial record Person
            {
                partial class Lens
                {
                    public static readonly global::Macaron.Optics.Lens<global::Person, string> Name = global::Macaron.Optics.Lens<global::Person, string>.Of(
                        getter: static source => source.Name,
                        setter: static (source, value) => source with
                        {
                            Name = value,
                        }
                    );
                }
            }

            """
        );
    }

    [Test]
    public void When_OptionalOfWithNullableProperties_Should_GenerateMaybeLenses()
    {
        AssertGeneratedCode(
            sourceCode:
            """
            using Macaron.Functional;

            namespace Macaron.Optics.Tests;

            public partial record Person(string Name, string? Email, int? Age);

            [OptionalOf(typeof(Person))]
            public static partial class PersonOptional
            {
            }
            """,
            expected:
            """
            // <auto-generated />
            #nullable enable

            namespace Macaron.Optics.Tests
            {
                partial class PersonOptional
                {
                    public static readonly global::Macaron.Optics.Optional<global::Macaron.Functional.Maybe<global::Macaron.Optics.Tests.Person>, string> Name = global::Macaron.Optics.Optional<global::Macaron.Functional.Maybe<global::Macaron.Optics.Tests.Person>, string>.Of(
                        optionalGetter: static source => source.IsJust
                            ? global::Macaron.Functional.Maybe.Just(source.Value.Name)
                            : global::Macaron.Functional.Maybe.Nothing<string>(),
                        setter: static (source, value) => source.IsJust
                            ? global::Macaron.Functional.Maybe.Just(source.Value with
                            {
                                Name = value,
                            })
                            : global::Macaron.Functional.Maybe.Nothing<global::Macaron.Optics.Tests.Person>()
                    );

                    public static readonly global::Macaron.Optics.Lens<global::Macaron.Functional.Maybe<global::Macaron.Optics.Tests.Person>, global::Macaron.Functional.Maybe<string>> Email = global::Macaron.Optics.Lens<global::Macaron.Functional.Maybe<global::Macaron.Optics.Tests.Person>, global::Macaron.Functional.Maybe<string>>.Of(
                        getter: static source => source is { IsJust: true, Value: { } value }
                            ? value.Email is { } value2
                                ? global::Macaron.Functional.Maybe.Just(value2)
                                : global::Macaron.Functional.Maybe.Nothing<string>()
                            : global::Macaron.Functional.Maybe.Nothing<string>(),
                        setter: static (source, value) => source.IsJust
                            ? global::Macaron.Functional.Maybe.Just(source.Value with
                            {
                                Email = value is { IsJust: true, Value: var value2 } ? value2 : null,
                            })
                            : global::Macaron.Functional.Maybe.Nothing<global::Macaron.Optics.Tests.Person>()
                    );

                    public static readonly global::Macaron.Optics.Lens<global::Macaron.Functional.Maybe<global::Macaron.Optics.Tests.Person>, global::Macaron.Functional.Maybe<int>> Age = global::Macaron.Optics.Lens<global::Macaron.Functional.Maybe<global::Macaron.Optics.Tests.Person>, global::Macaron.Functional.Maybe<int>>.Of(
                        getter: static source => source is { IsJust: true, Value: { } value }
                            ? value.Age is { } value2
                                ? global::Macaron.Functional.Maybe.Just(value2)
                                : global::Macaron.Functional.Maybe.Nothing<int>()
                            : global::Macaron.Functional.Maybe.Nothing<int>(),
                        setter: static (source, value) => source.IsJust
                            ? global::Macaron.Functional.Maybe.Just(source.Value with
                            {
                                Age = value is { IsJust: true, Value: var value2 } ? value2 : null,
                            })
                            : global::Macaron.Functional.Maybe.Nothing<global::Macaron.Optics.Tests.Person>()
                    );
                }
            }

            """
        );
    }
}
