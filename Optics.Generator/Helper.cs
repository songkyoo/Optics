using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Macaron.Optics.Generator;

internal static class Helper
{
    public const string MaybeTypeName = "global::Macaron.Functional.Maybe";
    public const string LensTypeName = "global::Macaron.Optics.Lens";

    public static INamedTypeSymbol? GetLensOfType(GeneratorSyntaxContext generatorSyntaxContext, string containingType)
    {
        var genericNameSyntax = GetGenericNameFromInvocation((InvocationExpressionSyntax)generatorSyntaxContext.Node);
        if (genericNameSyntax is null)
        {
            return null;
        }

        var semanticModel = generatorSyntaxContext.SemanticModel;
        var methodSymbol = semanticModel.GetSymbolInfo(genericNameSyntax).Symbol as IMethodSymbol;
        if (methodSymbol?.IsStatic is not true ||
            methodSymbol.Name != "Of" ||
            ToFullyQualifiedName(methodSymbol.ContainingType) != containingType
        )
        {
            return null;
        }

        var typeArgumentList = genericNameSyntax.TypeArgumentList;
        if (typeArgumentList.Arguments.Count != 1)
        {
            return null;
        }

        var typeArgument = genericNameSyntax.TypeArgumentList.Arguments[0];
        var symbolInfo = semanticModel.GetSymbolInfo(typeArgument);
        if (symbolInfo.Symbol is not INamedTypeSymbol namedTypeSymbol)
        {
            return null;
        }

        // Nullable한 형식은 지원하지 않는다.
        if ((namedTypeSymbol.IsValueType && namedTypeSymbol.ToString().EndsWith("?")) ||
            typeArgument.ToString().EndsWith("?")
        )
        {
            return null;
        }

        // with 문을 지원하는 형식만 사용한다.
        return namedTypeSymbol.IsRecord || namedTypeSymbol.TypeKind == TypeKind.Struct
            ? namedTypeSymbol
            : null;

        #region Local Functions
        static GenericNameSyntax? GetGenericNameFromInvocation(
            InvocationExpressionSyntax invocationExpressionSyntax
        )
        {
            return invocationExpressionSyntax.Expression switch
            {
                MemberAccessExpressionSyntax { Name: GenericNameSyntax genericName } => genericName,
                GenericNameSyntax genericName => genericName,
                _ => null
            };
        }
        #endregion
    }

    public static ImmutableArray<(string, string[])> GenerateLensOfMembers(INamedTypeSymbol typeSymbol)
    {
        var members = typeSymbol
            .GetMembers()
            .Where(symbol => symbol.DeclaredAccessibility == Accessibility.Public)
            .Where(symbol =>
                (symbol is IPropertySymbol propertySymbol && IsValidProperty(propertySymbol)) ||
                (symbol is IFieldSymbol fieldSymbol && IsValidField(fieldSymbol))
            )
            .ToArray();
        if (members.Length == 0)
        {
            return ImmutableArray<(string, string[])>.Empty;
        }

        var builder = ImmutableArray.CreateBuilder<(string, string[])>();
        var typeName = ToFullyQualifiedName(typeSymbol)!;

        for (int j = 0; j < members.Length; ++j)
        {
            var member = members[j];
            var memberTypeName = ToFullyQualifiedName(member is IPropertySymbol propertySymbol
                ? propertySymbol.Type
                : ((IFieldSymbol)member).Type
            );

            var lines = new List<string>
            {
                $"{LensTypeName}<{typeName}, {memberTypeName}>.Of(",
                $"    getter: static source => source.{member.Name},",
                $"    setter: static (source, value) => source with",
                $"    {{",
                $"        {member.Name} = value,",
                $"    }}",
                $");"
            };

            builder.Add(($"{LensTypeName}<{typeName}, {memberTypeName}> {member.Name}", lines.ToArray()));
        }

        return builder.ToImmutable();
    }

    public static StringBuilder CreateStringBuilderWithFileHeader()
    {
        var stringBuilder = new StringBuilder();
        stringBuilder.AppendLine("// <auto-generated />");
        stringBuilder.AppendLine("#nullable enable");
        stringBuilder.AppendLine();

        return stringBuilder;
    }

    public static string? ToFullyQualifiedName(ISymbol? symbol)
    {
        return symbol?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
    }

    public static bool IsValidProperty(IPropertySymbol propertySymbol)
    {
        if (propertySymbol.NullableAnnotation == NullableAnnotation.Annotated ||
            propertySymbol.GetMethod is null ||
            propertySymbol.IsIndexer
        )
        {
            return false;
        }

        return propertySymbol.SetMethod is not null or { IsReadOnly: true };
    }

    public static bool IsValidField(IFieldSymbol fieldSymbol)
    {
        return !fieldSymbol.IsConst &&
            !fieldSymbol.IsStatic &&
            !fieldSymbol.IsReadOnly &&
            fieldSymbol.NullableAnnotation != NullableAnnotation.Annotated;
    }
}
